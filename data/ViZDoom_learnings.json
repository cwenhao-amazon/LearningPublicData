[
  {
    "type": "tech_choices",
    "summary": "# Tech Choices for ViZDoom\n\nViZDoom is a Doom-based AI research platform that provides a 3D environment for reinforcement learning experiments. The project combines game engine technology with machine learning capabilities through a multi-language architecture.\n\n## Programming Languages\n\n- **C++**: Core implementation language for the main library and engine modifications\n- **Python**: Provides bindings for the C++ core, used for most examples and testing\n- **Julia**: Additional language bindings for broader accessibility\n\nThe project uses a C++ core with language bindings, allowing researchers to use their preferred language while maintaining performance.\n\n## Backend Technologies\n\n- **Modified ZDoom engine**: The project is built on a customized version of the Doom game engine\n- **Shared memory IPC**: Used for communication between the game engine and controlling applications\n- **Message queues**: Facilitates inter-process communication for game state and control\n\n## API Design Patterns\n\n- **C++ core API with language bindings**: Provides a consistent interface across supported languages\n- **Shared memory architecture**: Enables efficient data transfer between processes\n- **Cross-language compatibility**: Same functionality available in C++, Python, and Julia\n\n## Machine Learning Frameworks\n\n- **PyTorch**: Supported with examples and dedicated Docker configuration\n- **TensorFlow**: Supported with examples and dedicated Docker configuration\n- **Theano**: Example implementations provided\n- **Stable Baselines**: Example implementations for reinforcement learning\n\nThe project is designed to work with multiple ML frameworks, giving researchers flexibility in their tooling choices.\n\n## Build Systems\n\n- **CMake**: Used throughout the project for build configuration and management\n\n## Package Management\n\n- **pip**: Used for Python package distribution and installation\n\n## Testing Frameworks\n\n- **Python unit testing**: Used to test various functionalities including state management, action execution, and the Gym wrapper\n\n## Infrastructure & Deployment\n\n- **Docker**: Multiple Dockerfiles provided for different environments:\n  - Python 3 environment\n  - PyTorch-specific configuration\n  - TensorFlow-specific configuration\n\nDocker containers simplify setup and ensure consistent environments across different systems.\n\n## CI/CD Tools\n\n- **GitHub Actions**: Used for continuous integration and automated builds\n\n## Version Control Systems\n\n- **Git**: Standard version control with support for submodules",
    "data": null
  },
  {
    "type": "team_preferences",
    "summary": "# ViZDoom Team Preferences Summary\n\nThis summary outlines the working style and organizational approach of the ViZDoom team based on repository analysis. The team maintains a well-structured codebase with clear organization patterns, comprehensive coding guidelines, and established testing practices.\n\n## Code Organization\n\nThe ViZDoom project follows a modular organization structure:\n\n- Core library code in `src/lib/`\n- Language bindings in `src/lib_python/` and `src/lib_julia/`\n- Public headers in `include/`\n- Examples for different languages in `examples/` (Python, C++, Julia)\n- Tests in `tests/`\n\nThis organization reflects a clean separation of concerns between core functionality, language-specific bindings, and example code, making the codebase more maintainable and accessible to new contributors.\n\n## Version Control Workflows\n\nThe team employs GitHub Actions for CI with a multi-platform build approach:\n\n- CI triggers on push and pull requests to the master branch\n- Builds and tests on multiple operating systems:\n  - Ubuntu 18.04, 20.04\n  - macOS 10.15, 11.0\n- Tests against multiple Python versions (3.7, 3.8, 3.9, 3.10)\n- Workflow includes dependency installation, build verification, and import testing\n\nThis comprehensive CI approach ensures cross-platform compatibility and consistent functionality across different Python versions.\n\n## Coding Style Guidelines\n\nThe team follows detailed coding style guidelines:\n\n### File Organization\n- MIT license header at the top of each file\n- Include guards for header files using `#ifndef __FILE_NAME_H__` format\n- Grouped includes by category (project headers first, then external libraries, then standard libraries)\n- Forward declarations to minimize includes\n\n### Naming Conventions\n- **Classes**: PascalCase (e.g., `DoomGame`, `DoomController`)\n- **Methods/Functions**: camelCase (e.g., `makeAction`, `isRunning`)\n- **Variables**: camelCase (e.g., `lastReward`, `doomRunning`)\n- **Constants/Enums**: ALL_CAPS with underscores (e.g., `DEFAULT_TICRATE`)\n- **Member variables**: `this->` prefix for clarity\n- **Private member variables**: camelCase without special prefix\n\n### Code Formatting\n- 4-space indentation\n- Opening braces on the same line for functions and control structures\n- Spaces around operators and after commas\n- No spaces between function name and opening parenthesis\n- Empty lines to group related code blocks\n\n### Comments\n- `/* */` for multi-line comments\n- `//` for single-line comments\n- Descriptive comments for public API methods\n- Section comments using `/*----...----*/` format\n\n### Error Handling and Memory Management\n- Exception-based error handling with custom exception classes\n- Smart pointers for resource management\n- RAII pattern for resource handling\n- Cleanup in destructors\n\n### Namespace Usage\n- All code in the `vizdoom` namespace\n- Namespace aliases for external libraries\n\nThese comprehensive guidelines ensure consistency across the codebase and make it easier for new contributors to adapt to the project's style.\n\n## Testing Philosophy\n\nThe team employs unit testing for core functionality:\n\n- Tests focus on API functionality and integration points\n- Test files cover various components:\n  - Multiple instance handling\n  - Labels buffer functionality\n  - State retrieval\n  - Enumeration handling\n  - Action execution\n  - Gym wrapper integration\n  - Recording functionality\n\nThis testing approach ensures that core functionality remains stable and that API changes don't break existing behavior.\n\n## Issue Style Guidelines\n\nThe repository includes an issue template (`ISSUE_TEMPLATE.md`), indicating standardized reporting for bugs and feature requests. This helps maintain consistency in issue reporting and makes it easier for maintainers to triage and address problems.",
    "data": null
  },
  {
    "type": "non_functional_specs",
    "summary": "# Non-functional Specifications for ViZDoom\n\nThis document summarizes the identified non-functional specifications for the ViZDoom repository, focusing on key aspects that define the system's operational characteristics beyond its functional features.\n\n## Performance Requirements\n\nViZDoom includes dedicated benchmarking tools to measure and optimize performance, particularly focusing on frames per second (FPS) as a critical metric:\n\n- **FPS Benchmarking Tool**: The repository contains a Python script (`examples/python/fps.py`) specifically designed to measure performance with configurable parameters:\n  - Screen resolution (default: 320x240)\n  - Screen format (default: CRCGCB)\n  - Optional buffers (depth, labels, automap) that can be enabled/disabled\n  - Window visibility settings (can be disabled for maximum performance)\n  - Configurable number of iterations (default: 10,000)\n\nThe benchmarking tool measures how many game iterations can be processed per second, including state copying to simulate real usage scenarios. This allows developers to understand the performance characteristics of the framework on their specific hardware and how different configuration options affect performance.\n\n## Scalability Expectations\n\nViZDoom is designed to support multiple simultaneous instances, which is particularly important for reinforcement learning and AI training scenarios:\n\n- **Multiple Instance Support**: The repository includes example scripts and tests demonstrating how to run multiple instances:\n  - Basic multiple instances example (`examples/python/multiple_instances.py`)\n  - Advanced multiple instances example (`examples/python/multiple_instances_advance.py`)\n  - Testing for many instances (`tests/test_many_instances.py`)\n\nThis capability is crucial for parallel training of AI agents and for scenarios requiring multiple environments to be simulated simultaneously.\n\n## Network Requirements\n\nViZDoom supports multiplayer scenarios, indicating network functionality is a core non-functional requirement:\n\n- **Multiplayer Support**: The repository includes several examples and configuration files for multiplayer scenarios:\n  - CIG multiplayer examples (`examples/python/cig_multiplayer.py`, `examples/python/cig_multiplayer_host.py`, `examples/python/cig_multiplayer_bots.py`)\n  - Multiplayer recording capabilities (`examples/python/record_multiplayer.py`)\n  - Multiplayer configuration files (`scenarios/multi_duel.cfg`, `scenarios/multi.cfg`)\n  - Multiplayer game assets (`scenarios/multi_deathmatch.wad`)\n\nThese resources demonstrate that ViZDoom is designed to handle network communication between multiple instances, allowing for competitive or cooperative multiplayer scenarios that can be used for more complex AI training environments.",
    "data": null
  }
]