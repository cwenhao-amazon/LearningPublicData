[
  {
    "type": "tech_choices",
    "summary": "# Tech Choices Summary\n\nThis repository is primarily focused on optimizing machine learning models for Graphcore Intelligence Processing Units (IPUs). It's a Python-based project that integrates with popular machine learning frameworks and provides tools for deploying models on Graphcore hardware.\n\n## Programming Languages\n\n- **Python**: The repository is built entirely with Python, following standard Python packaging conventions\n- Evidenced by core files like `setup.py`, `pyproject.toml`, and `pytest.ini`\n\n## Infrastructure & Deployment\n\n- **Graphcore IPUs**: The project is specifically designed for optimizing and deploying machine learning models on Graphcore Intelligence Processing Units\n- Contains dedicated directories like `optimum/graphcore/` and educational notebooks such as `notebooks/introduction_to_optimum_graphcore.ipynb` and `notebooks/managing_ipu_resources.ipynb`\n\n## Machine Learning Frameworks\n\n- **PyTorch**: Core ML framework used as indicated by files like `optimum/graphcore/trainer_pt_utils.py`\n- **Hugging Face Transformers**: Integration with Hugging Face's ecosystem for implementing models like BERT, T5, GPT-2\n- **Diffusers**: Support for stable diffusion models via `optimum/graphcore/diffusers/` directory\n- The repository includes numerous notebooks demonstrating the usage of these frameworks with Graphcore IPUs\n\n## Testing Frameworks\n\n- **pytest**: Used as the primary testing framework\n- Configured with `pytest.ini` and organized in the `tests/` directory\n- Automated testing implemented through GitHub Actions workflows\n\n## Build Systems\n\n- **setuptools**: Used for building the Python package\n- Evidenced by `setup.py`, `pyproject.toml`, and `MANIFEST.in`\n\n## Package Management\n\n- **pip**: Standard Python package manager used throughout the project\n- Multiple `requirements.txt` files in various directories for dependency management\n\n## CI/CD Tools\n\n- **GitHub Actions**: Used for continuous integration and deployment\n- Workflows include:\n  - Code quality checks\n  - Testing (examples, pipelines, general)\n  - Documentation building\n- Configuration files located in `.github/workflows/`\n\n## Version Control Systems\n\n- **Git**: Standard version control system\n- Evidenced by `.git/` directory and `.gitignore` file",
    "data": null
  },
  {
    "type": "team_preferences",
    "summary": "# Team Preferences Summary\n\nThis summary outlines the working style and organizational approach of the Optimum Graphcore team based on repository analysis. The team demonstrates a structured, quality-focused development process with clear standards for code organization, review processes, and testing.\n\n## Code Organization\n\nThe team employs a modular package structure with clear separation of concerns:\n\n- Models are organized in dedicated directories (`optimum/graphcore/models/`)\n- Pipelines have their own section (`optimum/graphcore/pipelines/`)\n- Utilities are separated (`optimum/graphcore/utils/`)\n- Specialized components have dedicated locations:\n  - Data handling (`optimum/graphcore/data/`)\n  - Generation functionality (`optimum/graphcore/generation/`)\n  - Custom operations (`optimum/graphcore/custom_ops/`)\n\nThis organization reflects a preference for maintainable, modular code that separates different functional areas.\n\n## Version Control Workflows\n\nThe team follows a pull request-based workflow with integrated CI checks:\n\n- Pull requests are required for code changes\n- Automated CI workflows validate code before merging:\n  - Code quality checks\n  - Pipeline tests\n  - Example tests\n  - General test suite\n\nThis approach ensures code quality is maintained through automated verification before changes are accepted.\n\n## Coding Style Guidelines\n\nThe team maintains comprehensive coding style guidelines:\n\n### Formatting and Style\n- Black for code formatting with default settings (88 character line length)\n- Ruff for linting and additional style checks\n- 4-space indentation\n- Double quotes for strings consistently\n- Trailing commas in multi-line collections\n- Single blank line between logical sections\n\n### Naming Conventions\n- Classes: PascalCase (e.g., `QuantizationConfig`)\n- Functions/Methods: snake_case (e.g., `get_supported_tasks`)\n- Variables: snake_case (e.g., `supported_tasks`)\n- Constants: UPPER_SNAKE_CASE (e.g., `ONNX_WEIGHTS_NAME`)\n- Private attributes/methods: prefix with underscore (e.g., `_check_task_type`)\n\n### Project Structure\n- Main code in `optimum/` directory\n- Tests in `tests/` directory\n- Examples in `examples/` directory\n- CI workflows in `.github/workflows/`\n\n### Code Organization\n- Grouped imports (standard first, third-party second, local third)\n- Explicit imports rather than wildcard imports\n- Public functions/classes documented with docstrings\n- Single-responsibility functions\n\n## Code Review Standards\n\nThe team employs a structured code review process:\n\n### PR Description Requirements\n- Clear title reflecting the contribution (important as titles appear in release notes)\n- Detailed description of changes\n- Reference to fixed issues when applicable\n- Explanation of motivation and context\n- List of dependencies required for the change\n\n### Pre-submission Checklist\n- Documentation updates matching code changes\n- New tests for new functionality\n- Special exemption for typo fixes or documentation improvements\n\n### Review Process\n- Reviewers provide feedback on code quality\n- Follow-up with reviewers if no response after one week\n- Specific reviewers mentioned using @-mentions\n\n## Testing Philosophy\n\nThe team values comprehensive testing across multiple levels:\n\n- Unit tests for individual components\n- Pipeline tests for integration scenarios\n- Example tests to ensure compatibility with the Transformers library\n- Tests for various aspects including:\n  - Custom operations\n  - Models\n  - Trainers\n  - Pipelines\n  - IPU configuration\n\nThis extensive test coverage demonstrates a commitment to code quality and correctness.\n\n## PR Style Guidelines\n\nThe team has specific requirements for pull request formatting:\n\n### PR Title Requirements\n- Descriptive titles reflecting the full contribution\n- Suitable for inclusion in release notes\n- Clearly indicating the purpose of changes\n\n### PR Description Format\n- Starts with \"What does this PR do?\" section\n- Includes detailed explanation of changes\n- References fixed issues with \"Fixes #(issue)\" format\n- Explains motivation and context\n- Lists any dependencies required for the change\n\n### PR Checklist Structure\n- Uses GitHub-style checkboxes (- [ ])\n- Verification of documentation updates\n- Verification of test coverage\n- Special handling for typo fixes and documentation improvements\n\n### PR Follow-up Process\n- Follow up with reviewers after one week of inactivity\n- Use @-mentions for reviewer notifications",
    "data": null
  },
  {
    "type": "non_functional_specs",
    "summary": "# Non-functional Specifications for Graphcore IPU Optimization Repository\n\nThis document summarizes the key non-functional specifications identified in the repository focused on optimizing machine learning models for Graphcore Intelligence Processing Units (IPUs).\n\n## Performance Requirements\n\nThe repository is fundamentally focused on performance optimization for Graphcore IPU hardware. This includes:\n\n- Custom operations specifically designed for IPU architecture\n- IPU-specific configurations and optimizations\n- Specialized implementation patterns to maximize IPU performance\n\nThe entire structure of the repository (including directories like `optimum/graphcore/` and `optimum/graphcore/custom_ops/`) demonstrates that performance on IPU hardware is a primary concern and design goal.\n\n## Security Standards\n\nThe repository implements robust content safety filtering for AI-generated images through the `IPUStableDiffusionSafetyChecker` class, which provides:\n\n### Content Safety Mechanisms\n- Vision model-based detection of potentially unsafe content in generated images\n- NSFW (Not Safe For Work) content detection using:\n  - Cosine distance comparison between image embeddings and known unsafe concept embeddings\n  - Special care embeddings with weighted thresholds\n  - Adjustable filtering strength parameters\n\n### Security Implementation\n- Automatic blocking of images containing NSFW concepts by zeroing them out\n- Two-tier detection system with special care categories and general concept categories\n- Configurable threshold adjustment to balance between filtering strength and false positives\n\nThe implementation is specifically adapted for IPU hardware while maintaining the security standards of the original `StableDiffusionSafetyChecker`, showing attention to both performance and safety concerns.\n\n## Memory/CPU Constraints\n\nThe repository implements a detailed resource management system for Graphcore IPU hardware with specific constraints:\n\n### IPU Resource Allocation Model\n- One model = one IPU device architecture\n- Models attach to specific IPUs and only release them when out of scope or explicitly detached\n- IPUs remain locked even when idle, requiring explicit resource management\n\n### Resource Monitoring\n- Uses `gc-monitor` utility to track IPU usage\n- Can filter monitoring by PID to see notebook-specific usage\n- Provides detailed card information and usage statistics\n\n### Resource Management Techniques\n- Explicit detachment via `model.detachFromDevice()` method\n- Reattachment by simply calling the pipeline again\n- Resource optimization through strategic attachment/detachment cycles\n\n### Performance Considerations\n- Keeping models attached provides faster inference (demonstrated with `timeit`)\n- Trade-off between performance and resource availability\n- Notebook environments require special attention due to long kernel lifetimes\n\nThe detailed attention to resource management highlights the importance of efficient memory and processing resource utilization in the IPU environment, especially in shared computing contexts.",
    "data": null
  }
]