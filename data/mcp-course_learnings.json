[
  {
    "type": "tech_choices",
    "summary": "# Tech Choices Summary\n\nThis repository primarily uses Python for backend development with a focus on web servers, webhooks, and GitHub Actions integration. The project appears to be educational in nature, with various starter and solution implementations for different units.\n\n## Programming Languages\n\nPython is the primary programming language used throughout the repository. This is evidenced by:\n- Numerous Python files (.py extensions) including server implementations\n- Webhook handlers and utility scripts\n- Configuration files like `pyproject.toml` and `requirements.txt`\n\n## Frontend Frameworks\n\n**Gradio** is used as the frontend framework for creating interfaces in this project. Documentation files reference Gradio for both server and client implementations across multiple units:\n- `units/en/unit2/gradio-server.mdx`\n- `units/en/unit2/gradio-client.mdx`\n- `units/en/unit1/gradio-mcp.mdx`\n- And corresponding Vietnamese translations\n\n## Backend Technologies\n\nThe project uses **Python web servers** (likely Flask or FastAPI) as evidenced by multiple server implementation files:\n- `projects/unit3/github-actions-integration/starter/server.py`\n- `projects/unit3/slack-notification/starter/server.py`\n- `projects/unit3/build-mcp-server/starter/server.py`\n- And corresponding solution implementations\n\n## API Design Patterns\n\n**Webhooks** are used as the primary API design pattern for event-driven communication:\n- Multiple webhook server implementations (`webhook_server.py`)\n- Documentation about webhook listeners (`units/en/unit3_1/webhook-listener.mdx`)\n- This pattern enables asynchronous communication between different components of the system\n\n## Infrastructure & Deployment\n\n**GitHub Actions** is used for infrastructure and deployment:\n- Workflow files in `.github/workflows/` directory\n- Documentation about GitHub Actions integration\n- Used for CI/CD and automation of various processes\n\n## Testing Frameworks\n\nThe project uses **Python's testing framework** (likely pytest) as shown by:\n- Multiple test files following the naming convention `test_*.py`\n- Test files present for different components across various units\n\n## Package Management\n\n**Python package management** tools are used:\n- `requirements.txt` for traditional pip dependency management\n- `pyproject.toml` for modern Python packaging\n- `uv.lock` files suggest the use of `uv` as a package manager alongside or instead of traditional pip\n\n## CI/CD Tools\n\n**GitHub Actions** serves as the CI/CD tool:\n- Workflow files for building and uploading documentation\n- Integration with the project's components\n- Documentation specifically about GitHub Actions integration\n\n## Version Control Systems\n\n**Git** is used for version control:\n- Standard Git directory structure (`.git/`)\n- Configuration files and hooks\n- `.gitignore` file for specifying untracked files",
    "data": null
  },
  {
    "type": "team_preferences",
    "summary": "# Team Preferences Summary\n\nThis repository appears to be an educational or tutorial-focused project organized into units and projects, with a clear emphasis on structured development practices and code quality.\n\n## Code Organization\n\nThe repository follows a well-defined structure:\n- Organized by units and projects\n- Each project contains both starter and solution directories\n- Content is divided into units (units/en/unit1, units/en/unit2, etc.)\n- Projects are organized by unit (projects/unit3/...)\n\nThis structure suggests an educational focus, allowing learners to start with the starter code and compare against the provided solutions.\n\n## Version Control Workflows\n\nThe team employs a feature branch workflow with these key characteristics:\n- Developers work on feature branches\n- Pull requests are used for code integration\n- Conventional commit format is required\n- At least one approval is required before merging\n- Squashing commits is recommended before merging\n- CI checks must pass before merging\n- Issues/tickets are referenced in PR descriptions\n- Feature branches are deleted after merging\n\nThis approach emphasizes code quality through review and maintains a clean commit history.\n\n## Coding Style Guidelines\n\nThe team follows comprehensive coding standards:\n\n### General Principles\n- Follow PEP 8 style guide for Python\n- Maximum line length: 100 characters\n- Use descriptive variable names\n- Use type hints for all function arguments and return values\n- Prefer f-strings over .format() or % formatting\n\n### Code Organization\n- One class per file for major components\n- Group related functionality into modules\n- Use __init__.py to control public API\n- Keep functions under 50 lines when possible\n- Organize imports in standard library, third-party, local groups\n\n### Documentation\n- All public functions need Google-style docstrings\n- Include usage examples for complex functions\n- Keep README files up to date\n- Document parameters, returns, raises, and examples\n\n### Git Practices\n- Use conventional commit format: type(scope): description\n- Types: feat, fix, docs, style, refactor, test, chore\n- Keep commit messages under 72 characters\n- Reference issue numbers when applicable\n\n### Testing\n- All new features must include tests\n- Maintain >80% test coverage\n- Use pytest for Python tests\n- Test edge cases and error conditions\n- Mock external dependencies\n\n## Code Review Standards\n\nThe team implements a structured code review process:\n\n### PR Size and Structure\n- PRs should be under 500 lines of changes\n- Large features should be split into multiple PRs\n- Each PR should contain one logical change\n- Refactoring should be separate from feature changes\n\n### PR Documentation\n- Clear explanation of what and why\n- Screenshots for UI changes\n- List of breaking changes\n- Testing instructions\n- References to related issues/tickets\n\n### Review Process\n- At least one approval required before merging\n- All review comments must be addressed\n- PR description should be updated with changes made\n- Conflicts must be resolved before requesting review\n- Relevant team members should be tagged\n\n### Pre-merge Requirements\n- All CI checks must pass\n- Documentation must be updated if needed\n- No sensitive data should be exposed\n- Commits should be squashed if necessary\n- Feature branches should be deleted after merge\n\n## PR Style Guidelines\n\nThe team has established specific PR guidelines documented in a dedicated file (`projects/unit3/team-guidelines/pr-guidelines.md`). These guidelines ensure consistency and quality in the PR process, covering aspects like:\n\n- PR title format following conventional commits\n- Description requirements\n- Review process\n- Merge requirements\n\n## Issue Style Guidelines\n\nThe team uses a structured approach to issue tracking with dedicated templates for different issue types:\n- Bug reports\n- Feature requests\n- Documentation updates\n- Performance improvements\n- Refactoring tasks\n- Security concerns\n- Testing requirements\n\nThis templated approach ensures that issues contain all necessary information for efficient resolution.\n\n## Commit Message Style Guidelines\n\nWhile the repository contains only a sample Git hook for checking duplicate Signed-off-by lines, the PR guidelines indicate that the team uses conventional commit format:\n- Format: `type(scope): description`\n- Types include: feat, fix, docs, style, refactor, test, chore\n- Messages should be under 72 characters\n- Issue numbers should be referenced when applicable\n\nThis standardized format improves commit history readability and facilitates automated changelog generation.",
    "data": null
  },
  {
    "type": "non_functional_specs",
    "summary": "# Non-functional Specifications Summary\n\n## Overview\n\nThis project employs a template-based approach to manage key non-functional aspects of the software development process. The primary focus areas identified include performance optimization, security updates, and code maintainability through refactoring. Each area follows a structured methodology with clear documentation requirements, testing expectations, and impact assessments to ensure quality and stability.\n\n## Performance Requirements\n\nThe project implements a systematic approach to performance optimization using a template-based methodology. This structured process ensures that performance improvements are properly documented, measured, and validated.\n\nKey elements of the performance requirements include:\n\n- **Documentation of performance issues** being addressed in each improvement\n- **Quantitative measurement** through before/after performance metrics\n- **Detailed documentation** of specific optimizations implemented\n- **Comprehensive testing requirements** including:\n  - Addition or updates to benchmarks\n  - Verification that functionality remains intact\n  - Testing under various load conditions\n\nThis methodical approach emphasizes measurement and validation, ensuring that performance improvements are quantifiable and don't negatively impact other aspects of the system.\n\n## Security Standards\n\nSecurity updates follow a template-based approach that prioritizes careful documentation and thorough testing. The security process is designed to address vulnerabilities while minimizing exposure risks.\n\nThe security standards include:\n\n- **Cautious description of security issues** without exposing vulnerabilities\n- **Impact assessment** to identify affected components and users\n- **Solution documentation** detailing how security issues are addressed\n- **Comprehensive security testing** requirements:\n  - Addition of security-specific tests\n  - Performance of penetration testing\n  - Verification that no new vulnerabilities are introduced\n- **References to security advisories** when applicable\n\nWhile specific security standards (like OWASP or NIST) aren't explicitly mentioned, the systematic approach demonstrates a commitment to security best practices.\n\n## Maintainability Goals\n\nCode maintainability is addressed through a structured refactoring process that emphasizes intentional code improvements with clear justification and risk management.\n\nThe maintainability approach includes:\n\n- **Clear documentation** of what code is being refactored and why\n- **Explicit motivation** for undertaking refactoring work\n- **Detailed listing** of specific refactoring changes\n- **Comprehensive testing requirements**:\n  - Verification that all existing tests pass\n  - Confirmation that no functional changes occur\n  - Assessment of performance impact\n- **Risk assessment** for all refactoring changes\n\nThis approach ensures that refactoring work improves code quality over time while managing the risks associated with code changes.",
    "data": null
  }
]